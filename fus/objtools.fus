

sig: obj key -> bool
def has:
    dup is_arr ifelse:
        # key is an arr of syms
        ='keys ='obj
        do l:
            'keys len 0 == if: T ='bool break l
            ''keys lpop ='key ='keys
            'obj 'key has not if: F ='bool break l
            ''obj 'key get ='obj
        ''bool
    :
        # key is a sym
        has

sig: obj key -> value
def get: null @dget

sig: obj key default -> value
def dget:
    ='default
    dup is_arr ifelse:
        # key is an arr of syms
        ='keys ='obj
        do l:
            'keys len 0 == if: 'obj ='value break l
            ''keys lpop ='key ='keys
            'obj 'key has not if: 'default ='value break l
            ''obj 'key get ='obj
        ''value
    :
        # key is a sym
        ='key ='obj
        'obj 'key has ifelse: 'obj 'key get
        : 'default

sig: obj key -> obj value
def rip: null @drip

sig: obj key default -> obj value
def drip:
    over is_arr ifelse:
        # key is an arr of syms
        @drip_keys

        sig: obj keys default -> obj value
        def drip_keys:
            ='default ='keys ='obj
            'keys len 0 > ifelse:
                ''keys lpop ='key ='keys
                'obj 'key has not ifelse: ''obj 'default
                :
                    ''obj 'key rip
                        'keys 'default @drip_keys ='value
                    'key set
                    ''value
            :
                # This is kind of weird, but makes the recursion work out.
                # Does it make any sense, conceptually?
                # "Ripping with an empty array of keys rips the object
                # out of null" ...or something
                null 'obj
    :
        # key is a sym
        ='default ='key ='obj
        ''obj dup 'key has ifelse: 'key rip
        : 'default

sig: obj value key -> obj
def set:
    dup is_arr ifelse:
        # key is an arr of syms
        @set_keys

        sig: obj value keys -> obj
        def set_keys:
            ='keys ='value ='obj
            'keys len 0 > ifelse:
                ''keys lpop ='key ='keys
                ''obj 'key rip
                    ''value ''keys @set_keys
                'key set
            :
                ''value
    :
        # key is a sym
        set



sig: obj str -> obj
def add_prefix:
    # Example:
    #     (obj 1 =.x 2 =.y) "la" @obj_add_prefix -> (obj 1 =.lax 2 =.lay)

    ='prefix ='o0
    obj ='o1

    ('o0 keys) do loop:
        dup len 0 > while loop
        lpop ='key0
        'key0 sym_tostr 'prefix swap str_join str_tosym ='key1
        ''o1 'o0 'key0 get 'key1 set ='o1
    drop

    ''o1



sig(->)
def test:
    obj 1 =.x 2 =.y ='o
    'o `x @get 1 == assert
    'o `z @get is_null assert
    'o `z "LOL" @dget "LOL" str_eq assert

    (obj 1 =.x (obj 2 =.x) =.child) ='parent
    'parent (arr `x,) @get 1 == assert
    'parent (arr `child, `x,) @has assert
    'parent (arr `child, `y,) @has not assert
    (arr `child, `x,) ='key
    'parent 3 'key @set 'key @get 3 == assert
    'parent 'key @get 2 == assert
    'parent 'key @has assert

    'parent 'key @rip
        2 == assert
    'key @get is_null assert

    'o "__" @add_prefix ='o2
    'o2 ?.x not assert
    'o2 ?.__x assert
    'o2 ?.y not assert
    'o2 ?.__y assert

