
sig new: -> heap
sig add: heap value -> heap key
sig has: heap key -> bool
sig get: heap key -> value
sig set: heap value key -> heap
sig del: heap key -> heap


@test

def test(->):
    @new ='h
    ''h "Lawl" @add ='k1 ='h
    ''h "Rawr" @add ='k2 ='h
    ''h "Rofl" 'k1 @set ='h

    'h 'k1 @get "Rofl" str_eq assert
    'h 'k2 @get "Rawr" str_eq assert

    'h 'k1 @has assert
    ''h 'k1 @del ='h
    'h 'k1 @has not assert




use def: simple new
use def: simple add
use def: simple has
use def: simple get
use def: simple set
use def: simple del

module simple:
    # SIMPLE HEAP IMPLEMENTATION:
    #
    # Keys are integers, key-value pairs are stored in a big array,
    # search algorithm is linear.
    # An improved heap would e.g. use a binary tree instead of an
    # array.

    sig find: heap key -> index


    def new new:
        obj
            0 =.next_key
            arr =.entries

    def add add:
        ='v ='h
        ''h
            ..next_key dup ='k 1 + =.next_key
            ..entries obj 'k =.key 'v =.value push =.entries
        'k

    def find find:
        ='k ='h
        'h .entries ='entries
        0 'entries len do loop:
            over over >= if: null ='i break loop
            swap dup ='i 1 + swap
            'entries 'i .$ .key 'k == if: break loop
        drop drop
        'i

    def has has:
        @find is null not

    def get get:
        over ='h
        @find ='i
        'h .entries 'i .$ .value

    def set set:
        swap ='v
        over ='h
        @find ='i
        ''h
            ..entries 'i ..$ 'v =.value 'i =.$ =.entries

    def del del:
        over ='h
        @find ='i
        ''h
            ..entries 'i split lpop drop join =.entries
