
defsig new: -> heap
defsig add: heap value -> heap key
defsig has: heap key -> bool
defsig get: heap key -> value
defsig set: heap value key -> heap
defsig del: heap key -> heap


sig(->) def test:
    @new ='heap
    ''heap "Lawl" @add ='key1 ='heap
    ''heap "Rawr" @add ='key2 ='heap
    ''heap "Rofl" 'key1 @set ='heap

    'heap 'key1 @get "Rofl" str_eq assert
    'heap 'key2 @get "Rawr" str_eq assert

    'heap 'key1 @has assert
    ''heap 'key1 @del ='heap
    'heap 'key1 @has not assert



# SIMPLE HEAP IMPLEMENTATION:
#
# Keys are integers, key-value pairs are stored in a big array,
# search algorithm is linear.
# An improved heap would e.g. use a binary tree instead of an
# array.

defsig find: heap key -> index


sig new def new:
    obj
        0 =.next_key
        arr =.entries

sig add def add:
    ='value ='heap
    ''heap
        ..next_key dup ='key 1 + =.next_key
        ..entries (obj 'key =.key 'value =.value), =.entries
    'key

sig find def find:
    ='key ='heap
    'heap .entries ='entries
    0 'entries len do loop:
        over over >= if: null ='i break loop
        swap dup ='i 1 + swap
        'entries 'i .$ .key 'key == if: break loop
    drop drop
    'i

sig has def has:
    @find is_null not

sig get def get:
    over ='heap
    @find ='i
    'heap .entries 'i .$ .value

sig set def set:
    swap ='value
    over ='heap
    @find ='i
    ''heap
        ..entries 'i ..$ 'value =.value 'i =.$ =.entries

sig del def del:
    over ='heap
    @find ='i
    ''heap
        ..entries 'i split lpop drop join =.entries
