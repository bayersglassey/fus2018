
sig new: -> heap
sig add: heap value -> heap key
sig has: heap key -> bool
sig get: heap key -> value
sig set: heap value key -> heap
sig del: heap key -> heap


def test(->):
    @new ='heap
    ''heap "Lawl" @add ='key1 ='heap
    ''heap "Rawr" @add ='key2 ='heap
    ''heap "Rofl" 'key1 @set ='heap

    'heap 'key1 @get "Rofl" str_eq assert
    'heap 'key2 @get "Rawr" str_eq assert

    'heap 'key1 @has assert
    ''heap 'key1 @del ='heap
    'heap 'key1 @has not assert



# SIMPLE HEAP IMPLEMENTATION:
#
# Keys are integers, key-value pairs are stored in a big array,
# search algorithm is linear.
# An improved heap would e.g. use a binary tree instead of an
# array.

sig find: heap key -> index


def new new:
    obj
        0 =.next_key
        arr =.entries

def add add:
    ='value ='heap
    ''heap
        ..next_key dup ='key 1 + =.next_key
        ..entries (obj 'key =.key 'value =.value), =.entries
    'key

def find find:
    ='key ='heap
    'heap .entries ='entries
    0 'entries len do loop:
        over over >= if: null ='i break loop
        swap dup ='i 1 + swap
        'entries 'i .$ .key 'key == if: break loop
    drop drop
    'i

def has has:
    @find is null not

def get get:
    over ='heap
    @find ='i
    'heap .entries 'i .$ .value

def set set:
    swap ='value
    over ='heap
    @find ='i
    ''heap
        ..entries 'i ..$ 'value =.value 'i =.$ =.entries

def del del:
    over ='heap
    @find ='i
    ''heap
        ..entries 'i split lpop drop join =.entries
