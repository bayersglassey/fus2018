
def test of(->):
    @KEYWORDS ='keywords
    @TEST_PROGRAMS ='datas

    'datas keys arr_for: ='key
        'datas 'key get ='data

        "PROGRAM: " str_p 'key sym_tostr str_p "\n" str_p

        obj ='vars
        'keywords ''vars 'data @calc_sig ='ok ='err ='out ='in ='vars
        'ok not ifelse:
            "  Couldn't calc sig!\n" str_p
            "    ERR: " str_p 'err p
        :
            "  SIG: " str_p
            'in 'out @sig_p
            "\n" str_p

            "  VARS: " str_p
            'vars @vars_p
            "\n" str_p


###############################################################################
# TYPE

def type_p of(x ->):
    ='x
    'x is_str if: 'x str_p break
    'x is_int if: 'x int_tostr str_p break
    'x is_sym if: 'x sym_tostr str_p break
    'x is_arr if: 'x @stack_p break
    obj
        "Bad type (data can only contain int, str, sym, arr)" =.msg
        'x =.x
    error

def type_match of (l r -> bool):
    # If we try to consume l as if it were r, do we have any chance of
    # succeeding?
    ='r ='l
    'r `any sym_eq if:
        # everything matches `any
        T break
    'l `any sym_eq if:
        # `any might be anything, so might match anything
        T break
    'l 'r sym_eq


###############################################################################
# VARS

def vars_p of(vars ->):
    ='vars
    T ='first
    'vars keys arr_for: ='key
        'vars 'key get ='val
        'first ifelse(F ='first)(" " str_p)
        "(" str_p
        'key @type_p
        " " str_p
        'val @type_p
        ")" str_p


###############################################################################
# STACK

def stack_p of(stack ->):
    T ='first
    arr_for: ='x
        'first ifelse(F ='first)(" " str_p)
        'x @type_p

def stack_pop_n of(stack n -> substack):
    # Pop n elements off right side of a "stack".
    # Example: data(int str any) 2 @stack_pop_n -> data(int)
    ='n ='stack
    'stack len ='len
    ''stack 0 ('len 'n -) slice

def stack_match of(lhs rhs -> lhs rhs ok):
    # Matches elements (syms representing types) of "stacks" lhs and rhs.
    # The elements are popped & compared one at a time.
    # Returns (lhs rhs ok), where lhs and rhs are the stacks (modified by
    # popping), and ok indicates success or failure (type mismatch).
    # Examples:
    #     data(int str) data(arr any str) @stack_match -> data() data(arr) T
    #     data(int str) data(any arr) @stack_match -> data(int) data(any) F
    ='rhs ='lhs
    T ='ok
    0 ='n
    do:
        'rhs len 0 > and('lhs len 0 >) while
        ''rhs pop ='r ='rhs
        ''lhs pop ='l ='lhs
        'l 'r @type_match not if: F ='ok break
        loop

    'lhs 'rhs 'ok


###############################################################################
# SIG

def sig_p of(in out ->):
    ='out ='in
    'in len 0 > if: 'in @stack_p " " str_p
    "->" str_p
    'out len 0 > if: " " str_p 'out @stack_p

def sig_join of(in_l out_l in_r out_r -> in out ok):
    # Joins two signatures, returning a signature.
    # The 'ok param indicates type match or mismatch.
    # If 'ok is false, 'in and 'out are invalid and should not be used.
    #
    # A signature is a pair of arrs representing "stack effects".
    # The first ("in") arr represents popping a series of elements from the
    # stack, the second ("out") arr represents pushing a series of elements
    # onto the stack.

    ='out_r ='in_r ='out_l ='in_l

    # Right-hand signature "consumes" from left-hand one
    ''out_l ''in_r @stack_match ='ok ='in_r ='out_l

    'ok not if:
        # type mismatch -> no valid way to determine in, out
        null null F break

    # NOTE: If there was no type mismatch, then one or both of
    # in_r, out_l are empty arrs.
    # So one or both of the following are a no-op.
    ''in_l  ''in_r  join ='in
    ''out_l ''out_r join ='out

    'in 'out T

def calc_sig of(keywords vars data -> vars in out err ok):
    ='data ='vars ='keywords
    'data len ='data_len
    arr ='in arr ='out T ='ok null ='err
    0 ='i do:
        'i 'data_len < while
        'data 'i .$ ='word

        arr ='word_in
        arr ='word_out
        do:
            'word is_int if: arr `int, ='word_out break
            'word is_str if: arr `str, ='word_out break
            'word is_arr if:
                'keywords ''vars 'word @calc_sig
                ='ok ='err ='word_out ='word_in ='vars
                break
            'word is_sym if:
                'keywords 'word has not if:
                    obj
                        "Keyword not found" =.msg
                        'word =.word
                        'i =.i
                    ='err
                    F ='ok break
                'keywords 'word get ='keyword

                'keyword .in ='word_in
                'keyword .out ='word_out
                'keyword .args ='word_args

                arr ='args
                'i 1 + ='new_i
                'word_args arr_for: ='word_arg
                    'new_i 'data_len >= if:
                        obj
                            "Hit end of data, expected argument" =.msg
                            'word =.word
                            'i =.i
                            'data 'i ('data_len 'i -) slice =.data_slice
                        ='err
                        F ='ok break

                    'data 'new_i .$ ='arg
                    'arg typeof 'word_arg @type_match not if:
                        obj
                            "Unexpected argument type" =.msg
                            'word =.word
                            'i =.i
                            ('new_i 'i -) =.arg_offset
                            'word_arg =.word_arg
                            'arg =.arg
                        ='err
                        F ='ok break

                    ''args 'arg, ='args
                    ''new_i 1 + ='new_i loop
                'new_i 1 - ='i

                do:
                    'word ` =' sym_eq if:
                        # VAR SET
                        'args 0 .$ ='var_name

                        :
                            'out len 0 == ifelse: `any
                            : 'out (dup len 1 -) .$
                        ='var_type

                        'vars 'var_name has if:
                            'vars 'var_name get ='var_oldtype
                            'var_type 'var_oldtype @type_match not if:
                                obj
                                    "Unexpected var type" =.msg
                                    'word =.word
                                    'i =.i
                                    ('new_i 'i -) =.arg_offset
                                    'word_arg =.word_arg
                                    'arg =.arg
                                    'var_name =.var_name
                                    'var_oldtype =.var_oldtype
                                    'var_type =.var_type
                                ='err
                                F ='ok break

                        ''word_in pop drop 'var_type, ='word_in
                        ''vars 'var_type 'var_name set ='vars
                        break

                    'word ` ' sym_eq if:
                        # VAR GET
                        'args 0 .$ ='var_name

                        'vars 'var_name has not if:
                            obj
                                "Ref to missing var" =.msg
                                'word =.word
                                'i =.i
                                ('new_i 'i -) =.arg_offset
                                'word_arg =.word_arg
                                'arg =.arg
                                'var_name =.var_name
                            ='err
                            F ='ok break

                        'vars 'var_name get ='var_type
                        ''word_out pop drop 'var_type, ='word_out
                            # data(any) -> data()
                        break

                    'word ` '' sym_eq if:
                        # VAR RIP
                        'args 0 .$ ='var_name

                        # ?????

                        break

                break

            obj
                "Word has invalid type "
                "(data can only contain int, str, arr, sym)"
                str_join =.msg
                'word =.word
                'i =.i
            ='err
            F ='ok break

        'ok not if: break

        'in 'out 'word_in 'word_out @sig_join ='ok ='new_out ='new_in
        'ok not if:
            obj
                "Type mismatch" =.msg
                'word =.word
                'i =.i
                'in =.in 'out =.out
                'word_in =.word_in 'word_out =.word_out
            ='err
            F ='ok break
        ''new_in ='in
        ''new_out ='out

        ''i 1 + ='i loop

    'vars 'in 'out 'err 'ok


###############################################################################
# KEYWORDS

def keyword of(keywords op in out args -> keywords):
    obj
        swap =.args
        swap =.out
        swap =.in
        swap dup ='op =.op
    'op set

def KEYWORDS of(-> keywords):
    obj
        `   ' data() data(any) data(sym) @keyword
        `  '' data() data(any) data(sym) @keyword
        `  =' data(any) data() data(sym) @keyword
        `   . data(obj) data(any) data(sym) @keyword
        `  .. data(obj) data(obj any) data(sym) @keyword
        `  =. data(obj any) data(obj) data(sym) @keyword
        `  .$ data(arr int) data(any) data() @keyword
        ` ..$ data(arr int) data(arr any) data() @keyword
        ` =.$ data(arr any int) data(arr) data() @keyword
        `   + data(int int) data(int) data() @keyword
        `   - data(int int) data(int) data() @keyword
        `   * data(int int) data(int) data() @keyword
        `   / data(int int) data(int) data() @keyword
        `  == data(int int) data(bool) data() @keyword
        `  != data(int int) data(bool) data() @keyword
        `   > data(int int) data(bool) data() @keyword
        `   < data(int int) data(bool) data() @keyword
        `  >= data(int int) data(bool) data() @keyword
        `  <= data(int int) data(bool) data() @keyword
        `   , data(arr any) data(arr) data() @keyword

        # TODO: these should transform stack effects the same way they
        # transform the actual stack
        `swap data(any any) data(any any) data() @keyword
        `drop data(any) data() data() @keyword
        `dup data(any) data(any any) data() @keyword
        `nip data(any any) data(any) data() @keyword
        `over data(any any) data(any any any) data() @keyword

        `null data() data(null) data() @keyword
        `arr data() data(arr) data() @keyword
        `obj data() data(obj) data() @keyword
        `int_tostr data(int) data(str) data() @keyword
        `sym_tostr data(sym) data(str) data() @keyword
        `str_getcode data(str int) data(int) data() @keyword
        `str_setcode data(str int int) data(str) data() @keyword
        `str_join data(str str) data(str) data() @keyword
        `str_len data(str) data(int) data() @keyword
        `join data(arr arr) data(arr) data() @keyword
        `len data(arr) data(int) data() @keyword


###############################################################################
# TEST PROGRAMS

def TEST_PROGRAMS of(-> datas): obj

    # From fib.fus.
    # def next of(gen -> gen):
    data:
        ='gen

        # Get variables from object members:
        'gen .a ='a
        'gen .b ='b

        # Calculate next number in the sequence:
        ''a 'b + ='c

        # Return modified generator:
        ''gen:

            # Increment the index:
            ..i 1 + =.i

            # Push newest value onto the "cache" array:
            ..cache 'c, =.cache

            ''b =.a
            ''c =.b
    =.FIB_GEN_NEXT

    # From map_parser.fus.
    # def char_tostr of(i -> s):
    data: " " swap 0 str_setcode
    =.CHAR_TOSTR

    # From map_parser.fus.
    # def strchr of(s c -> i):
    data:
        ='c ='s
        null ='found_i
        's str_len int_for: ='i
            ('s 'i str_getcode) 'c == if:
                'i ='found_i break
        ''found_i
    =.STRCHR

    # From map_parser.fus.
    # def format of(arr -> str):
    data:
        "" swap arr_for: ='x
            'x is_int if: ''x int_tostr ='x
            ''x str_join
    =.FORMAT

    # From map_parser.fus.
    # def repeat of(elem n -> elems):
    data: swap ='elem arr swap int_for: drop 'elem,
    =.REPEAT

    # From map_parser.fus.
    # def max of(x y -> z):
    data: over over > ifelse(drop)(nip)
    =.MAX

    data: +
    =.ADD

    data: 1 ='x 'x
    =.VARTEST

    data: 1 dup
    =.DUPTEST
