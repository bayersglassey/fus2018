
stack len 0 == assert

"Stack" p
1 dup 1 == assert 1 == assert
1 2 drop 1 == assert
1 2 swap 1 == assert 2 == assert
1 2 nip 2 == assert
1 2 over 1 == assert 2 == assert 1 == assert
"ok" p

stack len 0 == assert

"Vars" p
1 ='x
'x 1 == assert
''x 1 == assert
'x is null assert
"ok" p

stack len 0 == assert

"Arithmetic" p
10 neg -10 == assert
1 2 +    3 == assert
1 2 -   -1 == assert
2 3 *    6 == assert
6 3 /    2 == assert
7 3 mod  1 == assert
# TODO: tests for "/" and "%" when there are negatives involved
3 4 == not assert
3 4 != assert
3 4 <  assert
3 4 <= assert
3 4 >  not assert
3 4 >= not assert
"ok" p

stack len 0 == assert

"Blocks" p
: # empty block
"ok" p

stack len 0 == assert

"Logic" p
y assert
n not assert
y y and assert
y n and not assert
n y and not assert
n n and not assert
y y or assert
y n or assert
n y or assert
n n or not assert
:
    y ='cond
    n if: n ='cond
    ''cond assert
:
    y ='cond
    y if: n ='cond
    ''cond not assert
:
    y ifelse: y ='cond
    : n ='cond
    ''cond assert
:
    n ifelse: y ='cond
    : n ='cond
    ''cond not assert
def which_nested_conditional_branch(b b -> i):
    # Returns 0, 1, 2, or 3 depending on which branch was reached
    ifelse:
        ifelse: 0 ='x
        : 1 ='x
    :
        ifelse: 2 ='x
        : 3 ='x
    ''x
y y @which_nested_conditional_branch 0 == assert
n y @which_nested_conditional_branch 1 == assert
y n @which_nested_conditional_branch 2 == assert
n n @which_nested_conditional_branch 3 == assert
"ok" p

stack len 0 == assert

"Arrays" p
arr 1, 2, 3, ='a
'a 0 .$ 1 == assert
'a 1 .$ 2 == assert
'a
    20 1 =.$
    pop drop
    pop 20 == assert
drop
'a len 3 == assert
'a lpop 1 == assert len 2 == assert
'a pop 3 == assert len 2 == assert
"ok" p

stack len 0 == assert

"Objects" p
obj 1 =.x 2 `y set
    dup keys len 2 == assert
    dup ?.x assert
    dup ?.z not assert
    dup `x get 1 == assert
    dup `y rip 2 == assert .y is null assert
drop
"ok" p

stack len 0 == assert

"Loops" p
arr ='a
0 3 do loop:
    over over < while loop
    swap 1 + swap
    1 2 do loop:
        over over <= while loop
        swap
            ''a over, ='a
        1 + swap
    drop drop
drop drop
''a
    lpop 1 == assert
    lpop 2 == assert
    lpop 1 == assert
    lpop 2 == assert
    lpop 1 == assert
    lpop 2 == assert
len 0 == assert
"ok" p

stack len 0 == assert

"Modules & Functions" p
module ModuleTest:
    sig F: -> i

    def f F: 2

    def test(-> bool):
        fun F: 1
        ='f

        @f 2 == assert
        'f call F 1 == assert
        &f call F 2 == assert

        y
@(ModuleTest test) assert
"ok" p

stack len 0 == assert
