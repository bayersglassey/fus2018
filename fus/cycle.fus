
sig const: -> x
def unbox(boxed -> unboxed): call const


module Cycle:

    # NOTE: Currently we can't see const or unbox from within
    # Cycle.
    # Do we import them explicitly?
    # Or do we do the usual "search up the lexical hierarchy"?
    # If the latter, when is that done?
    # I guess it would be at the end of
    # fus_compiler_compile_frame_from_lexer.
    # And it raises some questions:
    # - If we have references to an uncompiled frame, and we
    #     get to the end of the surrounding module, that uncompiled
    #     frame should essentially become a ref.
    #     But that means... well, I guess that's fine.
    #     We could alternatively iterate over all frames in the
    #     module, and update any which had references to the undefined
    #     frame.
    #     But I think that's too crazy for now.

    def A const:
        obj
            100 =.label
            &B =.link
    def B const:
        obj
            200 =.label
            &C =.link
    def C const:
        obj
            300 =.label
            &A =.link

    def test(->):
        # The links of A, B, C form a cycle.
        # We follow the links by unboxing them.
        # The compiler should be smart enough to cache
        # the values of defs with signature (-> x),
        # so even if we form a really big directed graph
        # structure, there should be no cost to following
        # its links.

        @A
            dup .label 100 == assert
            .link @unbox
            dup .label 200 == assert
            .link @unbox
            dup .label 300 == assert
            .link @unbox
            dup .label 100 == assert
        drop

@(Cycle test)
