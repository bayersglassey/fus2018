
Sep 8, 2018:
------------

Need "load data(...)".
The latter is like "data(...)" but loaded from a file (like "load(...)").


Nov 14, 2018:
-------------

While running the following:
    ./uwsgi/run --fus_execpost
And then running the following in separate terminal:
    ./uwsgi/curl_test "21"
We get this error:
    <no file>: row 1: col 1: split token "21": Lexer finished with status != done (OK)


Also, fus_runner_dump shows 1 sym past where it needs to.
Because calls increment i *before* pushing new frame.
You see?..


Nov 28, 2018:
-------------

Similar to "tuple", how about "tovars" and "tokeys":

    1 2 3 tovars: x y z
    1 2 3 obj tokeys: x y z


Files, modules, imports, etc:

    # load fus/format.fus as module Format:
    load Format: fus format

    # or like this?.. (I prefer the former because it doesn't have to know about file systems)
    load Format "fus/format.fus"

    # Use defs tostr and format from module Format:
    from Format: tostr format

    # Use and rename defs:
    from Format: tostr =f format =g

By the way,

    module M: ...

...is just shorthand for:

    def M of(->): ...

Also, I think the following is valid:

    module M:
        fun of(->):
            def f of(-> i): 1
    from M: f
    @f 1 == assert

...that is, you can't hide "def f" inside a fun.
It's always possible to get at any def via a suitable chain of "from".

So how do def lookups work?
    Get rid of runner->data, runner->defs.
    We will be using fun->data, fun->defs.
    Callframes already have a pointer to fun, which is good.
    We want to store loaded files as an array of funs. (On runner?..)
    Or I guess we want a fus_file_t:

        typedef struct fus_file {
            char *filepath;
            bool loaded;
            fus_fun_t fun;
        } fus_file_t;


Nov 30, 2018:
-------------

do vs int_for, arr_for:
The behaviour of "loop" is markedly different when you're in a do-block
vs a for-block.
It makes it difficult to refactor ('n int_for: ='i ...) into
(0 ='i do: ... ''i 1 - ='i loop) because there's no way for code in the
(...) of the do-block to say "please do whatever you do each step of the
loop", e.g. (''i 1 - ='i).


Jan 11, 2019:
-------------

Runner state as fus value:

    obj # state
        arr # callstack
            obj # callframe
                fun() =.fun
                arr =.stack
                obj =.vars
                arr # blockstack
                    obj # block
                        `do =.type
                        arr =.code
                        0 =.code_i
                    ,
                =.blockstack
            ,
        =.callstack
    ='state

A block's type is used to determine the behaviour of break and loop.

    def f():
        ='x ='y
        ('x 'y +) ='z

    # Right after entering ('x 'y +), the blockstack looks like:

    arr
        obj
            `def =.type
            :
                ='x ='y
                ('x 'y +) ='z
            =.code
            4 =.code_i
        ,
        obj
            `paren =.type
            ('x 'y +) =.code
            0 =.code_i
        ,

    

How are def and module handled?
Or @ and &, for that matter?

    def add: +

    module Vec:
        def new: ...
        def add: ...

    1 2 @add


    # renaming local name
    use: add =int_add

    @@Vec new @@Vec new @@Vec add

    use Vec: new add
    @new @new @add


Modules:
They live in a big array, and at runtime are referred to by index.
Each fun has an obj mapping names to module indices.

    arr # modules
        obj
            0 =.i
            `add =.name
            fun(...) =.fun
            obj # defs
                1 =.Vec
            =.defs
            obj # refs
            
            =.refs
        ,
        obj
            0 =.i
            `add =.name
            fun(...) =.fun
            obj # refs
            
            =.refs
        ,
    ='modules

MODULES AND DEFS ARE TOTALLY DIFFERENT THINGS.
modules hold defs, defs hold code.
defs are... just funs?

    obj # root
        obj # defs
            fun() =.
        =.defs
        obj # modules
        =.modules
    ='root


Jan 14, 2019:
-------------

    # ADD "TO_VARS"

    # Equivalent lines:
    to_vars: a b c
    ='c ='b ='a

    # Can't do from_vars because don't know whether to use 'x or ''x.
    # But that's fine, since when pushing to stack from vars, the vars
    # are listed in "correct order":
    #     'a 'b 'c
    #     ''a ''b ''c
    # ...etc.

