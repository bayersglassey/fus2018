

Sep 2, 2018:
------------

Need better debugging of compiler, similar to how state has nicer error messages now
(But even state's debug info is lacking -- should tell you row & col of an error!..)

Keep track of stack size & check it against signature...


Our current approach to name resolution, where we try to do everything as soon as
possible and convert things to refs as needed, is overcomplicated.
Much easier to first generate the complete tree of frames, *then* resolve all
references.
We still need TYPE_REF, for "use" -- maybe *only* for "use"?..


Sep 3, 2018:
------------

Review compiler frame->row, frame->col stuff...
I had the following happen:

  Executing opcode < at byte 23/224
    In DEF 8 (apply_sounds) at row=8, col=0
    In MOD 1 (music) at row=2, col=3 [file:fus/music.fus]

...when apply_sounds should have been row=44, col=1.
For that matter, should col=0 even be possible??


Sep 8, 2018:
------------

Need "load data(...)".
The latter is like "data(...)" but loaded from a file (like "load(...)").


Oct 15, 2018:
-------------

newvalues: mkunique can currently return a thing with refcount 0 or 1...
    What should the behaviour be?
    Presumably we always want it to return a thing with a specific refcount.
    Perhaps it's an error to pass it something which has refcount 0?
    -> YES. More importantly, values should be created with refcount 1
        and all fus_ functions should transfer/modify refcounts differently.
        E.g. fus_arr_push does NOT affect refcount of pushed object: it
        assumes you're PASSING ownership to the arr value.
        Similarly, fus_arr_pop passes ownership.
        Drop could be implemented as fus_arr_pop followed by
        fus_value_detach.

I think we need two prefixes, one for the "safe API" and one for the
"unsafe API".
The safe API deals with e.g. fus_boxed_t, fus_unboxed_t, bool, etc.
The unsafe API deals with nothing but fus_value_t.
So who gets the "fus_" prefix, and what is the other prefix?..
    * "fus_" unsafe, "fuss_" safe
    * "fus_" unsafe, "sfus_" safe
    * "ufus_" unsafe, "fus_" safe
    * "usfus_" unsafe, "fus_" safe
    * "fusu_" unsafe, "fus_" safe
    * "fusus_" unsafe, "fus_" safe

...I think I like ufus (unsafe) and fus (safe).
(Really I prefer usfus, but ufus is easier to type...)

Or, fus_value_* is the safe prefix?
    fus_arr_len()
    fus_value_arr_len()
    fus_is_arr()
    fus_value_is_arr()

ALSO: fus_int_decode, fus_sym_decode, fus_bool_decode:
    If the type is wrong, how do we report it?
    We're not returning a fus value, so we can't return fus_err(...).
    Do we pass a pointer to the value to be decoded, and turn it into
    a fus_err if it's the wrong type????
    Or do we add fus_vm_err() which is called by fus_err()?
    ...it's not really "safe" since the error has escaped the VM
    as a "decoded" thing, but at least VM can choose to bring the house
    down with an abort, or whatever... hmmmmm.
    Current approach where we get nice debug output is maybe superior option.

